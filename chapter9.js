function Rectangle(w, h) {	this.width = w;	this.height = h;}var rect1 = new Rectangle(2, 4);var rect2 = new Rectangle(8.5, 11);function computeAreaOfRectangle(r) { return r.width * r.height; }var r = new Rectangle(8.5, 11);r.area = function() { return this.width * this.height; };var a = r.area();function Rectangle2(w, h) {	this.width = w;	this.height = h;	this.area = function( ) { return this.width * this.height; };}function Rectangle3(w, h) {	this.width = w;	this.height = h;}Rectangle3.prototype.area = function() { return this.width * this.height; };var r = new Rectangle(2, 3);r.hasOwnProperty("width");r.hasOwnProperty("area");String.prototype.endsWith = function(c) {	return (c == this.charAt(this.length - 1));};var message = "azaza";message.endsWith('h');message.endsWith('a');if (!Array.prototype.map) {	Array.prototype.map = function(f, thisObject) {		var results = [];		for(var len = this.length, i = 0; i < len; i++) {			results.push(f.call(thisObject, this[i], i, this));		}		return results;	};}function Circle(radius) {	this.r = radius;}var c = new Circle(1.0);c.r = 2.2;var a = c.area();var x = Math.exp(Circle.PI);var d = new Circle(1.2);var bigger = Circle.max(c,d);// Комплексные числа дохуяfunction Complex(real, imaginary) {	this.x = real;	this.y = imaginary;}Complex.prototype.magnitude = function() {	return Math.sqrt(this.x*this.x + this.y*this.y);};Complex.prototype.negative = function() {	return new Complex(this.x, this.y);};Complex.prototype.add = function(that) {	return new Complex(this.x + that.x, this.y + that.y);};Complex.prototype.multiply = function(that) {	return new Complex(this.x * that.x, this.y * that.y, this.x * that.y + this.y * that.x);};Complex.prototype.toString = function() {	return "{" + this.x + "," + this.y + "}";};Complex.prototype.equals = function(that) {	return this.x == that.x && this.y == that.y;};Complex.prototype.valueOf = function() {	return this.x;};Complex.add = function (a, b) {	return new Complex(a.x + b.x, a.y + b.y);};Complex.multiply = function (a, b) {	return new Complex(a.x * b.x, a.y * b.y, a.x * b.y + a.y * b.x);};Complex.ZERO = new Complex(0,0);Complex.ONE = new Complex(1,0);Complex.I = new Complex(0,1);function ImmutableRectangle(w, h) {	this.getWidth = function() {		return w;	};	this.getHeight = function() {		return h;	};}ImmutableRectangle.prototype.area = function( ) {	return this.getWidth( ) * this.getHeight( );};//function Rectangle(w, h) {this.width = w;this.height = h;}Rectangle.prototype.area = function( ) { return this.width * this.height; }function PositionedRectangle(x, y, w, h) {	Rectangle.call(this, w, h);	this.x = x;	this.y = y;}PositionedRectangle.prototype = new Rectangle();delete PositionedRectangle.prototype.width;delete PositionedRectangle.prototype.height;PositionedRectangle.prototype.constructor = PositionedRectangle;PositionedRectangle.prototype.contains = function(x,y) {	return (x > this.x && x < this.x + this.width &&	y > this.y && y < this.y + this.height);}function defineClass(data) {	var classname = data.name;	var superclass = data.extend || Object;	var constructor = data.construct || function( ) {};	var methods = data.methods || {};	var statics = data.statics || {};	var borrows;	var provides;	if (!data.borrows) borrows = [];	else if (data.borrows instanceof Array) borrows = data.borrows;	else borrows = [ data.borrows ];	if (!data.provides) provides = [];	else if (data.provides instanceof Array) provides = data.provides; else provides = [ data.provides ];	var proto = new superclass();for(var p in proto)	if (proto.hasOwnProperty(p)) delete proto[p];for(var i = 0; i < borrows.length; i++) {	var c = data.borrows[i];	borrows[i] = c;	￼￼    for(var p in c.prototype) {		if (typeof c.prototype[p] != "function") continue;		proto[p] = c.prototype[p];	} }for(var p in methods) proto[p] = methods[p];	proto.constructor = constructor;	proto.superclass = superclass;if (classname) proto.classname = classname;for(var i = 0; i < provides.length; i++) {	var c = provides[i];	for(var p in c.prototype) {	} }	if (typeof c.prototype[p] != "function") continue;	if (p == "constructor" || p == "superclass") continue;	if (p in proto &&		typeof proto[p] == "function" &&		proto[p].length == c.prototype[p].length) continue;		throw new Error("Класс " + classname + " не предоставляет метод "+		c.classname + "." + p);		constructor.prototype = proto;		for(var p in statics) constructor[p] = data.statics[p];		return constructor;	}